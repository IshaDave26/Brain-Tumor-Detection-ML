# -*- coding: utf-8 -*-
"""A066_A102_A108_CNN+SVM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nCdQ1Yx9PvKY1y9x3q_UCmvS-uDrP_j2
"""

#importing libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from PIL import Image

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, confusion_matrix
from sklearn.svm import SVC
from sklearn.preprocessing import LabelEncoder

import tensorflow as tf
from keras.models import Sequential
from keras.layers import Conv2D, MaxPooling2D, Flatten, Dense

# Load the image data and labels
data = pd.read_csv('/content/Brain Tumor test.csv')

# Modify the 'Image' column to include the full path to the images
data['Image'] = '/content/Brain Tumor/' + data['Image']

data.shape

# Load the images and labels
X = []
Y = []
for i in range(len(data)):
    img = Image.open(data['Image'][i] +  '.jpg')
    img = img.resize((128, 128))
    X.append(np.array(img))
    Y.append(data['Class'][i])

# Convert the labels to numerical values
le = LabelEncoder()
Y = le.fit_transform(Y)

# Split the data into training and testing sets
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.3, random_state=42)

# Define the CNN model
cnn_model = Sequential()
cnn_model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(128, 128, 3)))
cnn_model.add(MaxPooling2D(pool_size=(2, 2)))
cnn_model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))
cnn_model.add(MaxPooling2D(pool_size=(2, 2)))
cnn_model.add(Conv2D(128, kernel_size=(3, 3), activation='relu'))
cnn_model.add(MaxPooling2D(pool_size=(2, 2)))
cnn_model.add(Flatten())

#displaying model summary
cnn_model.summary()

# Define the SVM model
svm_model = SVC(kernel='linear')

# Train the CNN model
cnn_model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
history = cnn_model.fit(np.array(X_train), np.array(Y_train), epochs=10,validation_data=(np.array(X_test), np.array(Y_test)))

# Use the CNN model to extract features from the data
X_train_features = cnn_model.predict(np.array(X_train))
X_test_features = cnn_model.predict(np.array(X_test))

# Train the SVM model on the extracted features
svm_model.fit(X_train_features, Y_train)

# Make predictions on the test data
Y_pred = svm_model.predict(X_test_features)

# Evaluate the accuracy of the model
print('Accuracy:', accuracy_score(Y_test, Y_pred))
print('Confusion Matrix:\n', confusion_matrix(Y_test, Y_pred))

#plotting training and validation loss
plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('Training and Validation Loss')
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.legend(['Training Loss', 'Validation Loss'])
plt.show()

import itertools

# Calculate and print the accuracy score
accuracy = accuracy_score(Y_test, Y_pred)
print("Accuracy:", accuracy)

# Calculate and plot the confusion matrix
cm = confusion_matrix(Y_test, Y_pred)
plt.figure(figsize=(10, 8))
plt.imshow(cm, cmap=plt.cm.Blues)
plt.title("Confusion Matrix")
plt.colorbar()
tick_marks = np.arange(len(le.classes_))
plt.xticks(tick_marks, le.classes_, rotation=45)
plt.yticks(tick_marks, le.classes_)
plt.xlabel("Predicted Class")
plt.ylabel("True Class")

# Add text annotations to the confusion matrix
thresh = cm.max() / 2.
for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
    plt.text(j, i, format(cm[i, j], 'd'),
             horizontalalignment="center",
             color="white" if cm[i, j] > thresh else "black")

plt.show()